# CS-320
[Summary and Reflections Report.docx](https://github.com/user-attachments/files/17523585/Summary.and.Reflections.Report.docx)
[Project One.zip](https://github.com/user-attachments/files/17523584/Project.One.zip)

**Reflection for CS 320 Portfolio Submission**
This portfolio submission showcases my work in software testing, automation, and quality assurance through the Contact Service files from Project One and the Summary and Reflections Report from Project Two. These artifacts demonstrate my ability to create unit tests, interpret user requirements, and design software with functionality and security in mind.

**How Can I Ensure That My Code, Program, or Software is Functional and Secure?**
To ensure functionality and security, I use a combination of thorough testing and careful coding practices. Writing unit tests allows me to verify that each part of the program behaves as expected and meets the defined requirements. Automation tools allow tests to be run consistently to catch issues early. Security is addressed by following coding standards to minimize vulnerabilities, using input validation, and ensuring data privacy by handling sensitive information responsibly.

**How Do I Interpret User Needs and Incorporate Them into a Program?**
Understanding user needs starts with clearly analyzing the requirements and mapping them to program functionalities. In this course, for example, I ensured that user stories and requirements were accurately reflected in the features of the Contact Service. To achieve this, I frequently revisited the requirements while coding and testing to verify that all functionalities met the expectations set by the user or project stakeholders. Regular feedback loops are also essential, as they help refine the program to align closely with user needs.

**How Do I Approach Designing Software?**
I start the design process by breaking down requirements into smaller components and determining the main functionalities. I use principles like modularity and encapsulation to organize code, making each component easy to test and maintain. After planning the structure, I write pseudocode or diagrams to visualize the programâ€™s flow and interactions. This preparation allows me to identify potential issues early on and create a foundation that is easier to expand or modify in the future.
